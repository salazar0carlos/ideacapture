# IdeaCapture Database Documentation

This document provides comprehensive information about the IdeaCapture database schema, security policies, and migration procedures.

## Table of Contents

1. [Overview](#overview)
2. [Database Schema](#database-schema)
3. [Row Level Security (RLS) Policies](#row-level-security-rls-policies)
4. [Migration Instructions](#migration-instructions)
5. [Security Best Practices](#security-best-practices)
6. [Testing RLS Policies](#testing-rls-policies)
7. [Troubleshooting](#troubleshooting)

## Overview

The IdeaCapture database uses Supabase (PostgreSQL) with Row Level Security (RLS) enabled to ensure users can only access their own data. The database consists of two main tables:

- **ideas**: Stores user ideas with refinement and validation data
- **user_settings**: Stores per-user application settings

All data is protected by RLS policies that automatically filter queries based on the authenticated user's ID.

## Database Schema

### Tables

#### `ideas` Table

Stores all user ideas with their refinement and validation status.

```sql
CREATE TABLE ideas (
    -- Primary key
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    -- User ownership
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

    -- Core idea fields
    title TEXT NOT NULL,
    description TEXT,
    idea_type TEXT NOT NULL CHECK (idea_type IN ('tech', 'business', 'product', 'content', 'other')),
    audio_transcript TEXT,

    -- Refinement fields
    refinement_questions JSONB,
    refinement_answers JSONB,
    refinement_complete BOOLEAN DEFAULT FALSE,

    -- Validation fields
    validation_result JSONB,
    validation_enabled BOOLEAN DEFAULT FALSE,
    demand_score INTEGER CHECK (demand_score >= 0 AND demand_score <= 100),
    competition_score INTEGER CHECK (competition_score >= 0 AND competition_score <= 100),
    feasibility_score INTEGER CHECK (feasibility_score >= 0 AND feasibility_score <= 100),
    is_worth_pursuing BOOLEAN,

    -- Metadata
    status TEXT DEFAULT 'captured' CHECK (status IN ('captured', 'refining', 'validated', 'pursuing', 'archived')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Field Descriptions:**

- `user_id`: Foreign key to `auth.users(id)`. Automatically cascades deletes when user is removed.
- `idea_type`: Categorizes the idea (tech, business, product, content, or other)
- `status`: Tracks idea lifecycle (captured → refining → validated → pursuing/archived)
- `refinement_questions`: JSONB array of questions generated by AI
- `refinement_answers`: JSONB object of user answers keyed by question ID
- `validation_result`: JSONB object containing AI validation analysis
- Score fields: Integer scores (0-100) for demand, competition, and feasibility

#### `user_settings` Table

Stores per-user application preferences.

```sql
CREATE TABLE user_settings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    validation_enabled BOOLEAN DEFAULT FALSE,
    default_view TEXT DEFAULT 'list' CHECK (default_view IN ('list', 'grid', 'mindmap')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT user_settings_user_id_key UNIQUE (user_id)
);
```

**Field Descriptions:**

- `user_id`: Foreign key to `auth.users(id)`. One settings record per user (unique constraint).
- `validation_enabled`: Whether AI validation is enabled for new ideas
- `default_view`: Preferred UI view mode for displaying ideas

### Indexes

Performance indexes for common query patterns:

```sql
-- User lookup (critical for RLS)
CREATE INDEX idx_ideas_user_id ON ideas(user_id);
CREATE INDEX idx_user_settings_user_id ON user_settings(user_id);

-- Sorting and filtering
CREATE INDEX idx_ideas_created_at ON ideas(created_at DESC);
CREATE INDEX idx_ideas_idea_type ON ideas(idea_type);
CREATE INDEX idx_ideas_status ON ideas(status);
CREATE INDEX idx_ideas_is_worth_pursuing ON ideas(is_worth_pursuing);
```

### Triggers

**Auto-update `updated_at` timestamp:**

```sql
CREATE TRIGGER update_ideas_updated_at
    BEFORE UPDATE ON ideas
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

This trigger automatically sets `updated_at` to the current timestamp whenever an idea is updated.

## Row Level Security (RLS) Policies

### How RLS Works

Row Level Security is a PostgreSQL feature that automatically filters rows based on the current user's permissions. In IdeaCapture:

1. **Authentication**: User logs in via Supabase Auth, receives a JWT token
2. **JWT Decoding**: Supabase automatically decodes the JWT and sets `auth.uid()` to the user's ID
3. **Policy Enforcement**: All database queries are automatically filtered by RLS policies
4. **Access Control**: Users can only see/modify rows where `user_id = auth.uid()`

### `ideas` Table Policies

RLS is enabled on the `ideas` table with the following policies:

#### SELECT Policy
```sql
CREATE POLICY "Users can view their own ideas"
ON ideas FOR SELECT
USING (auth.uid() = user_id);
```
**Effect**: Users can only query their own ideas. Queries automatically filter `WHERE user_id = auth.uid()`.

#### INSERT Policy
```sql
CREATE POLICY "Users can create their own ideas"
ON ideas FOR INSERT
WITH CHECK (auth.uid() = user_id);
```
**Effect**: Users can only insert ideas with their own `user_id`. Attempts to insert with a different `user_id` will fail.

#### UPDATE Policy
```sql
CREATE POLICY "Users can update their own ideas"
ON ideas FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);
```
**Effect**: Users can only update their own ideas. The `USING` clause filters which rows can be updated, and `WITH CHECK` ensures the updated row still belongs to the user.

#### DELETE Policy
```sql
CREATE POLICY "Users can delete their own ideas"
ON ideas FOR DELETE
USING (auth.uid() = user_id);
```
**Effect**: Users can only delete their own ideas.

### `user_settings` Table Policies

Similar policies apply to the `user_settings` table:

```sql
-- SELECT
CREATE POLICY "Users can view their own settings"
ON user_settings FOR SELECT
USING (auth.uid() = user_id);

-- INSERT
CREATE POLICY "Users can create their own settings"
ON user_settings FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- UPDATE
CREATE POLICY "Users can update their own settings"
ON user_settings FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- DELETE
CREATE POLICY "Users can delete their own settings"
ON user_settings FOR DELETE
USING (auth.uid() = user_id);
```

### Anonymous Users

**Important**: Anonymous (unauthenticated) users have **no access** to any data. When not authenticated, `auth.uid()` returns `NULL`, which will never match any `user_id`, so all policies return empty results or deny operations.

## Migration Instructions

### For New Installations

If you're setting up the database for the first time:

1. Navigate to your Supabase project dashboard
2. Go to **SQL Editor**
3. Copy and paste the entire contents of `/supabase/schema.sql`
4. Click **Run** to execute

This will create all tables, indexes, triggers, and RLS policies from scratch.

### For Existing Installations

If you already have a database running the old schema (without proper RLS):

#### Step 1: Backup Your Data

```sql
-- Backup ideas table
CREATE TABLE ideas_backup AS SELECT * FROM ideas;

-- Backup user_settings table
CREATE TABLE user_settings_backup AS SELECT * FROM user_settings;
```

#### Step 2: Run Migration

1. Navigate to your Supabase project dashboard
2. Go to **SQL Editor**
3. Copy and paste the contents of `/supabase/migrations/001_add_user_id_and_rls.sql`
4. Click **Run** to execute

#### Step 3: Verify Migration

```sql
-- Check that user_id column exists
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'ideas' AND column_name = 'user_id';

-- Check RLS is enabled
SELECT tablename, rowsecurity
FROM pg_tables
WHERE schemaname = 'public'
AND tablename IN ('ideas', 'user_settings');

-- Check policies exist
SELECT schemaname, tablename, policyname, cmd
FROM pg_policies
WHERE tablename IN ('ideas', 'user_settings');
```

#### Step 4: Test Access Control

See the [Testing RLS Policies](#testing-rls-policies) section below.

### Migration Rollback (Emergency Only)

If you need to rollback the migration:

```sql
-- Restore from backup
DROP TABLE ideas;
DROP TABLE user_settings;
CREATE TABLE ideas AS SELECT * FROM ideas_backup;
CREATE TABLE user_settings AS SELECT * FROM user_settings_backup;

-- Re-enable old permissive policies
ALTER TABLE ideas ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_settings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all operations on ideas" ON ideas
    FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Allow all operations on user_settings" ON user_settings
    FOR ALL USING (true) WITH CHECK (true);
```

**Warning**: This rollback removes security protections!

## Security Best Practices

### 1. Always Use Authenticated Requests

Never bypass authentication in your API routes. Always verify the user is authenticated before creating the Supabase client:

```typescript
// ✅ CORRECT
const { user, error } = await getAuthenticatedUser(request);
if (error || !user) {
  return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
}
const supabase = createServerSupabaseClient(request);
```

```typescript
// ❌ WRONG - Never use admin/service role client for user queries
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY! // This bypasses RLS!
);
```

### 2. Trust RLS, But Verify

RLS is your primary security layer. The API routes now rely on RLS for access control rather than manual filtering:

```typescript
// ✅ CORRECT - RLS automatically filters by user_id
const { data } = await supabase
  .from('ideas')
  .select('*');

// ❌ OLD WAY - Manual filtering (now redundant with RLS)
const { data } = await supabase
  .from('ideas')
  .select('*')
  .eq('user_id', user.id); // RLS already does this
```

However, the authentication check is still required to ensure a valid user context exists.

### 3. Set user_id on INSERT

When inserting new records, always explicitly set the `user_id`:

```typescript
// ✅ CORRECT
const { data } = await supabase
  .from('ideas')
  .insert({
    title: 'My Idea',
    user_id: user.id, // Required!
    // ... other fields
  });
```

RLS will verify that `user_id` matches `auth.uid()`, so users can't spoof other users' IDs.

### 4. Never Disable RLS

```sql
-- ❌ NEVER DO THIS
ALTER TABLE ideas DISABLE ROW LEVEL SECURITY;
```

Disabling RLS removes all access control protections!

### 5. Service Role Key Security

Your `SUPABASE_SERVICE_ROLE_KEY` bypasses all RLS policies. **Never**:
- Expose it in client-side code
- Use it for user-facing operations
- Commit it to version control
- Share it in logs or error messages

Only use the service role key for:
- Admin operations
- Background jobs
- Migrations
- Testing (in isolated environments)

### 6. Regular Security Audits

Periodically verify your RLS policies:

```sql
-- List all policies
SELECT * FROM pg_policies WHERE schemaname = 'public';

-- Check for tables with RLS disabled
SELECT tablename, rowsecurity
FROM pg_tables
WHERE schemaname = 'public' AND rowsecurity = false;

-- Look for overly permissive policies
SELECT * FROM pg_policies
WHERE qual = 'true' OR with_check = 'true';
```

## Testing RLS Policies

### Test Setup

To properly test RLS policies, you need to test with actual authenticated users. Here's a testing approach:

#### 1. Create Test Users

Use Supabase Auth to create test users in your development environment.

#### 2. Test SELECT Policy

```sql
-- Authenticate as User A
-- Then run:
SELECT * FROM ideas;
-- Should only return User A's ideas

-- Authenticate as User B
-- Then run:
SELECT * FROM ideas;
-- Should only return User B's ideas (different from User A)
```

#### 3. Test INSERT Policy

```typescript
// Try to insert with your own user_id
const { data, error } = await supabase
  .from('ideas')
  .insert({
    title: 'Test Idea',
    user_id: currentUser.id, // Your own ID
    idea_type: 'tech'
  });
// ✅ Should succeed

// Try to insert with someone else's user_id
const { data, error } = await supabase
  .from('ideas')
  .insert({
    title: 'Test Idea',
    user_id: 'some-other-users-id',
    idea_type: 'tech'
  });
// ❌ Should fail with RLS violation
```

#### 4. Test UPDATE Policy

```typescript
// Create an idea as User A
// Then authenticate as User B
// Try to update User A's idea:
const { data, error } = await supabase
  .from('ideas')
  .update({ title: 'Hacked!' })
  .eq('id', userAIdeaId);
// ❌ Should fail (no rows updated)
```

#### 5. Test DELETE Policy

```typescript
// Similar to UPDATE test
// User B should not be able to delete User A's ideas
```

### Test with Anonymous Users

```typescript
// Create unauthenticated Supabase client (no JWT token)
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// Try to query
const { data, error } = await supabase.from('ideas').select('*');
// Should return empty array []
```

## Troubleshooting

### Problem: Users Can See Other Users' Data

**Cause**: RLS might not be enabled or policies aren't working correctly.

**Solution**:
```sql
-- 1. Verify RLS is enabled
SELECT tablename, rowsecurity FROM pg_tables
WHERE schemaname = 'public' AND tablename = 'ideas';
-- rowsecurity should be 't' (true)

-- 2. Check policies exist
SELECT * FROM pg_policies WHERE tablename = 'ideas';

-- 3. Test auth.uid()
SELECT auth.uid(); -- Should return your user ID when authenticated
```

### Problem: Can't Insert/Update Records

**Cause**: `user_id` might be missing or incorrect, or `auth.uid()` is NULL.

**Solution**:
```typescript
// 1. Verify user is authenticated
const { data: { user } } = await supabase.auth.getUser();
console.log('Authenticated user:', user?.id);

// 2. Ensure user_id is set correctly on insert
const { data, error } = await supabase
  .from('ideas')
  .insert({
    user_id: user.id, // Must match auth.uid()
    // ... other fields
  });

// 3. Check error message
console.error('Database error:', error);
```

### Problem: RLS Policies Not Taking Effect

**Cause**: Using service role key instead of user JWT token.

**Solution**:
```typescript
// ❌ WRONG - Service role bypasses RLS
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

// ✅ CORRECT - User JWT enforces RLS
const supabase = createServerSupabaseClient(request); // Uses JWT from request
```

### Problem: Migration Fails

**Common issues**:

1. **Column already exists**: Re-running migration when `user_id` already exists
   ```sql
   -- Check if column exists first
   SELECT column_name FROM information_schema.columns
   WHERE table_name = 'ideas' AND column_name = 'user_id';
   ```

2. **Foreign key constraint fails**: Orphaned records with no valid user
   ```sql
   -- Clean up orphaned records
   DELETE FROM ideas WHERE user_id IS NULL;
   ```

3. **Policy name conflicts**: Trying to create policies that already exist
   ```sql
   -- Drop existing policies first
   DROP POLICY IF EXISTS "Users can view their own ideas" ON ideas;
   ```

### Problem: Performance Issues

**Cause**: Missing indexes on `user_id` columns.

**Solution**:
```sql
-- Verify indexes exist
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename IN ('ideas', 'user_settings');

-- Create missing indexes
CREATE INDEX IF NOT EXISTS idx_ideas_user_id ON ideas(user_id);
CREATE INDEX IF NOT EXISTS idx_user_settings_user_id ON user_settings(user_id);

-- Analyze query performance
EXPLAIN ANALYZE
SELECT * FROM ideas WHERE user_id = 'some-uuid';
```

### Getting Help

If you're still experiencing issues:

1. Check Supabase logs in the dashboard (Logs → Postgres Logs)
2. Enable query logging to see what SQL is being executed
3. Review the Supabase RLS documentation: https://supabase.com/docs/guides/auth/row-level-security
4. Check the application logs for authentication errors

---

## Additional Resources

- [Supabase Row Level Security Guide](https://supabase.com/docs/guides/auth/row-level-security)
- [PostgreSQL RLS Documentation](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)
- [Supabase Auth Helpers](https://supabase.com/docs/guides/auth/auth-helpers)

---

**Last Updated**: 2025-11-11
**Database Version**: v1.1 (RLS enabled with proper user_id handling)
